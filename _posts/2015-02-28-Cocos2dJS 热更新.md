---
layout: post
title: Cocos2dJS 热更新
description: "Cocos2dJS HotFix的简单Demo"
modified: 2015-02-28
tags: [Cocos2d Cocos2dJS HotFix]
---

### 工作需要，在空闲时间看了下Cocos2dJS的热更新。对其进行了一个简单的实现，这里总结分享一下。忍不住吐槽一下Cocos2dJS的官方文档…版本落后很多，当前最新Release版本是V3.3，文档还是V3.0的东西，虽然有借鉴意义，不过感觉还是略坑，不能因为自己是开源就放松对文档的完善啊！国外大的开源项目，文档不都好好的么。

吐槽结束，开始干活！

##Cocos2dJS 热更新
Cocos2dJS 热更新是啥？Cocos2dJS终归还是一个游戏引擎，就以游戏的过程来理解吧。传统游戏需要更新人物动画、地图场景、游戏逻辑、背景音乐怎么办？新出一个APP放到应用商店等用户下载，或者好一点游戏内提示又升级并自行下载完整的新版本APP。<br/>
使用Cocos2dJS的热更新，那就大不一样了。它可以做到进入游戏后下载需要更新的资源甚至是脚本本身，而且更新过程不需要退出游戏。只要用户联网，就能够保证使用到最新的资源。<br/>
这些场景就非常适合使用Hot Fix

 * 想在游戏中对春节开放新活动，不能保证应用商店能准时过审核上线
 
 * 发现一个严重的Bug，需要立即修复
 
 * 需要经常换游戏资源，提升新鲜感
 
 * 先放一个中规中矩的版本过市场审核，然后绕过审核自己直接推新内容，哈哈
 
对于游戏来说，这个特性是比较重量级的。不过因为JavaScript的语言特性能支持这一功能，所以Cocos2dJS能用此特性，而Cocos2d-x无法使用。

##特性
以下是官方提供的特性

 * 多线程并行下载支持
 
 * 两层进度统计信息：文件级以及字节级
 
 * Zip压缩文件支持
 
 * 断点续传
 
 * 详细的错误报告
 
 * 文件下载失败重试支持
 
##Simple
 
 1.  ###manifest配置文件
热更新需要用到的配置文件有2种，都是以.manifest结尾。<br/>
一种是精简版，一种是完整版。精简版称为**version.manifest**，完整版称为**project.manifest**。<br/>
version.manifest：
 
{% highlight json %}
{
    "packageUrl" : "http://127.0.0.1:8080/JsUpdateServer/res", 
    "remoteManifestUrl" : "http://127.0.0.1:8080/JsUpdateServer/res/project.manifest", 
    "remoteVersionUrl" : "http://127.0.0.1:8080/JsUpdateServer/res/version.manifest", 
    "version" : "1.0.0",
    "groupVersions" : {
        "1" : "1.0.1",
        "2" : "1.0.2"
    },
    "engineVersion" : "3.3"
}
{% endhighlight %}

version.manifest是可选的，其中的所有字段也出现在project.manifest中，并且内容一样，如果没有就会从服务端下载完整版。但是如果完整版特别大，那么这个小版本的优势就很明显了。

project.manifest：

{% highlight json %}
{
    {
    "packageUrl" : "http://127.0.0.1:8080/JsUpdateServer/res", 
    "remoteManifestUrl" : "http://127.0.0.1:8080/JsUpdateServer/res/project.manifest", 
    "remoteVersionUrl" : "http://127.0.0.1:8080/JsUpdateServer/res/version.manifest", 
    "version" : "1.0.0",
    "groupVersions" : {
        "1" : "1.0.1",
        "2" : "1.0.2"
    },
    "engineVersion" : "3.3",
    "assets" : {
        "update1" : {
            "path" : "src/app.zip",
            "md5" : "41D8E948052B5B714B14F81612CF534D",
            "compressed" : true,
            "group" : "1"
        }, 
        "update2" : {
            "path" : "res/HelloWorld.png",
            "md5" : "A0FA3FA681D500575012D5E802F74D50",
            "group" : "1"
        },
        "update3" : {
            "path" : "res/Bound.png",
            "md5" : "E7D4218B02CD0C5BB35ADC55E133DBA2",
            "group" : "1"
        },
        "update4" : {
            "path" : "src/resource.js",
            "md5" : "BA47101EBB65FBFCFB61C4CC57A306CA",
            "group" : "2"
        }
    },
    "searchPaths" : [
    	"res/"
    ]
		}
}
{% endhighlight %}

所有字段具体含义，官方文档的定义还是比较详细，只是少了groupVersions这个新字段：

 * packageUrl : 远程资源的下载根路径。
 * remoteVersionUrl : 远程版本文件的路径，用来判断服务器端是否有新版本的资源。
 * remoteManifestUrl : 远程配置文件的路径，包含版本信息以及所有资源信息。
 * version : 配置文件对应的版本。
 * groupVersions : 是新增的功能字段，用于做增量更新很方便。
 * engineVersion : 配置文件对应的引擎版本。
 * assets : 所有资源信息。
:    key : 升级名称
:    path : 键代表资源的相对路径（相对于packageUrl）。
:    md5 : md5值代表资源文件的版本信息。
:    compressed : [可选项] 如果值为true，文件被下载后会自动被解压，目前仅支持zip压缩格式。
 * searchPaths : 需要添加到cocos2d引擎中的搜索路径列表。
 
 一个完整的更新流程是这样的：
 
 先通过本地的version.manifest和服务端的version.manifest比较，如果本地version低于服务端，那么就会再去获取project.manifest。
 
 如果version相同，那么会比较groupVersions。
 
 如果本地没有下载过groupVersions中的任何更新，那么会依次下载升级包。
 
 以我的配置为例，如果本地下载过1.0.1版本的升级包，那么就会跳过1.0.1下载属于1.0.2版本的升级内容。

 2.  ###创建后台
 
 3.  ###创建Cocos2dJS工程
 
 4.  ###在后台配置升级文件
 
 5.  ###回到Cocos2dJS工程